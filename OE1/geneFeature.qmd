---
title: "Análisis de Secuencias"
author: "Mathias"
format:
  html:
    theme: united
    code-fold: true
    code-link: true
    number-sections: true
    highlight-style: github
---

```{css}
#| echo: false

p {
  text-align: justify
}

```

```{r}
#| label: show-genome
#| echo: false
#| warning: false

## VARIABLES QUE DEBEN SER ARGUMENTOS ##
# Especificar el directorio donde están los archivos
directory <- "/home/usuario/Data_Rstudio/chop_genome"  # Cambia esto a la ruta de tu directorio
# leer tabla de datos ()
data_init <- read.delim("/home/usuario/Proyectos/maestria/datos_ejecucion_genomas2.tsv.csv", sep = "\t", header = FALSE)
########################################

# Obtener la lista de archivos que comienzan con 'out_' y terminan con '.fasta'
fasta_files <- list.files(path = directory, pattern = "^out_.*\\.fasta$", full.names = TRUE)
genome_name <- basename(data_init$V1)

genes_work <- basename(fasta_files)
prot_name <- sub(".*_:(.*):_.*", "\\1", fasta_files)
key_names <- sub("_.*", "\\1", prot_name)
key_name <- unique(sort(key_names))


```

## Descripcion

![](https://img.itch.zone/aW1nLzE3MTEyNjE5LmdpZg==/original/2%2BYVZg.gif){style="float:right;" fig-alt="Illustration of a detective cat. Artwork by @shigemi.itch.io." width="301"}

Los datos utilizados en este análisis fueron obtenidas a partir de diferentes genomas de *Trypanosoma cruzi*, disponibles en [**tritrydb**](https://tritrypdb.org/tritrypdb/app) y [**NCBI**](https://www.ncbi.nlm.nih.gov/).

A partir de estos genomas, se extrajeron secuencias de los genes ``r key_name``, con el objetivo de realizar análisis de contenido de `GC`, `longitud de las secuencias`, y otros aspectos relevantes para la caracterización de los genes de ``r key_name``.

### Genomas

Este análisis utiliza los siguientes genomas ``r genome_name``. A partir de los cuales se obtienen las secuencias para su estudio.

### Librerias y datos a usar

Se cargan las `bibliotecas` necesarias para el análisis de datos genómicos, así como para la manipulación, transformación y visualización de dataframes, junto con la generación de gráficos en formato de arreglo. A continuación, se crea una lista de archivos que contiene los `genomas` a analizar, y se inicializa una `tabla` destinada a almacenar los resultados del análisis de los archivos FASTA.

```{r}
#| label: load-packages
#| echo: true
#| warning: false

# Cargar las librerías necesarias
library(seqinr)
library(tidyverse)
library(gridExtra)
library(reactable)

```

## Procesamiento de los Archivos FASTA

Para procesar las secuencias FASTA, se crea una función que genera un dataframe vacío donde se almacenarán los elementos obtenidos a partir de una secuencia dada. Luego, se elimina la ruta del archivo para extraer el nombre del mismo. A continuación, se obtiene el identificador de cada una de las secuencias dentro del archivo FASTA, se calcula la longitud de la secuencia utilizando una función de la biblioteca SEQINR y, con otra función de la misma biblioteca, se calcula el porcentaje de bases GC. Finalmente, se agrega una fila de encabezado y se devuelve el resultado de la función.

```{r}
#| label: created function
#| echo: false
#| warning: false

calculate_fasta_feature <- function(fasta_files, type){
  
  all_results <- data.frame(file = character(), ID = character(), Length = numeric(), GC_Content = numeric(), stringsAsFactors = FALSE)

  # Leer cada archivo FASTA y calcular las métricas
  for (fasta_file in fasta_files) {
    # Leer el archivo FASTA
    fasta_content <- read.fasta(fasta_file)
    
    # Nombre base del archivo
    base_name <- basename(fasta_file)
    # Expresión regular para extraer las partes necesarias
    if(type == "genome"){
      extracted_names <- sub(".*_([^_]+)\\_Genome.fasta$", "\\1", base_name)
    } else if(type == "gene") {
      extracted_names <- sub(".*_([^_]+)\\.fasta$", "\\1", base_name)
      #extracted_names <- str_remove_all(extracted_names, "^.*_")  
    }

    
    # Procesar cada secuencia en el archivo FASTA
    for (sequence in fasta_content) {
      id <- attr(sequence, "name")
      length <- round(getLength(sequence), 0)
      gc_content <- round(GC(sequence), 3)
      
      # Añadir los resultados a la tabla
      all_results <- all_results %>%
        add_row(file = extracted_names, ID = id, Length = length, GC_Content = gc_content)
    }
  }
  
  return(all_results)

}

```

### Características de los genomas

Se llama a la función recien creada para extraer diversas características de los genomas. Estos datos son esenciales para analizar la composición genética de los genomas.

```{r}
#| label: extract genome feature and created summary
#| echo: true
#| warning: false

# Llamamos a la funcion para obtener GC y largo de cada contig, de cada genoma
# genomes <- calculate_fasta_feature(data_init$V1, "genome")

# path_genome_safe_tsv <- file.path("output_directory/", paste0("genome_gc_length.tsv"))
# path_genome_safe <- file.path("output_directory/", paste0("genome_gc_length.csv"))
# write.csv(genomes, file = path_genome_safe, row.names = FALSE, col.names = TRUE, quote = FALSE)
# write.table(genomes, file = path_genome_safe_tsv, row.names = FALSE, col.names = TRUE, sep = "\t", quote = FALSE)

# Load the table generated by the second script
genomes <- read.table("output_directory/genome_gc_length.tsv", sep = "\t", header = TRUE)


# Crear una tabla con el conteo de secuencias por archivo
genomes_summary <- genomes %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(genomes_summary, highlight = TRUE)

```


```{r}
#| label: plotting-genome-gc
#| fig-cap: "Secuencias por genoma y contenido GC."
#| echo: true
#| warning: false
#| layout: [[100]]

library(ggridges)
library(ggbeeswarm)
library(cowplot)

genomes$Length <- as.numeric((format(genomes$Length, scientific = TRUE))) # Changed format

# Determinar el número de columnas para el facet_wrap
num_files <- length(unique(genomes$file))


# Crear el violin plot para GC_Content
# Crear el violin plot para GC_Content
ggplot(genomes, aes(x = file, y = GC_Content, fill = file)) +
  geom_violin(alpha = 0.7, width = 0.5) + 
  geom_boxplot(width = 0.1, fill = "white", alpha = 0.3) +
  # geom_jitter(width = 0.1, alpha = 0.1, color = "black") +
  scale_fill_brewer(palette = "Dark2") +  # Aplicar la paleta Dark2 de RColorBrewer
  theme_minimal() +
  labs(
    x = "Archivo",
    y = "Contenido de GC"
  )

# ggplot(genomes, aes(x = file, y = Length, reorder(file, -Length, FUN=median), color = file)) +
#   # geom_violin(fill = palmer_colors[2], alpha = 0.7, width = 0.5) +
#   geom_violin(alpha = 0.7, width = 0.5, fill = "white") +
#   geom_boxplot(width = 0.1, fill = "white", alpha = 0.3) +
#   geom_quasirandom(groupOnX=FALSE, show.legend = FALSE, size = 3, dodge.width=0.9, alpha=.4) +
#   # geom_jitter(width = 0.1, alpha = 0.1, color = "black") +
#   scale_y_log10(
#     breaks = c(10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8, 10^9, 10^10),
#     labels = scales::trans_format("log10", scales::math_format(10^.x))
#   ) +
#   theme_minimal_vgrid() + 
#   theme(axis.title.y = element_blank(), axis.line.y = element_blank(),  axis.ticks.y = element_blank()) +
#   scale_color_brewer(palette="Dark2") +
#   xlab("Number of base pairs") +
#   labs(
#     title = "Genome size",
#     caption = "Data source: National Center for Biotechnology Information"
#   )


set.seed(12345)
genomes %>%
  ggplot(aes(Length, reorder(file, -Length, FUN=median), color = file)) +
  #geom_jitter(shape=".") +
  # geom_quasirandom(shape = ".", groupOnX=FALSE, show.legend = FALSE) +
  geom_quasirandom(groupOnX=FALSE, show.legend = FALSE, size = 1, dodge.width=0.9, alpha=.4) +
#  geom_density_ridges() +
  scale_x_log10(
    breaks = c(10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8, 10^9, 10^10),
    labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) +
  xlab("Number of base pairs") +
  labs(
    title = "Genome size",
    caption = "Data source: National Center for Biotechnology Information"
  ) +
  theme_minimal_vgrid() + 
  theme(axis.title.y = element_blank(), axis.line.y = element_blank(),  axis.ticks.y = element_blank()) +
  scale_color_brewer(palette="Dark2")


```

### Archivos en formato FASTA de las secuencias de `r key_name`

Se calculará el `%GC` y la `longitud` de las secuencias de `r key_name`: ``r genes_work``.

---

### Procesamiento de Archivos FASTA

Se leen las secuencias en formato FASTA, y para cada secuencia se extraen el `ID`, la `longitud (pb)` y el contenido de `GC (%)`. Estos datos se almacenan en una `tabla all_results`. Finalmente, se muestra esta tabla con los resultados obtenidos

```{r}
#| label: extract-info
#| echo: true
#| warning: false

all_results <- calculate_fasta_feature(fasta_files, "gene")

```

### Resumen de Información de `r key_name` en cada genoma

`Tabla resumen` agrupa las secuencias de `r key_name` por cada genoma, calculando el `número total de secuencias encontradas`, la `longitud` mínima, media y máxima, así como el contenido de `GC` mínimo, medio y máximo.

```{r}
#| label: summary-info
#| echo: false
#| warning: false

# Crear una tabla con el conteo de secuencias por archivo
file_sequence_counts <- all_results %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(file_sequence_counts, highlight = TRUE)

```

---

## Visualización de los Datos

Se crean gráficos para visualizar la `distribución del contenido de GC` (%) y la `longitud de las secuencias` (pb) de `r key_name` de cada genoma.

### Distribución del contenido de GC de las secuencias de `r key_name`

```{r}
#| label: plotting-gc
#| fig-cap: "Secuencias por genoma y contenido GC."
#| echo: true
#| warning: false
#| layout: [[100]]

# Paleta de colores de Palmer Penguins
palmer_colors <- c("#FF5A5F", "#00A699", "#FC642D", "#400080", "#d7d732")

# Determinar el número de columnas para el facet_wrap
num_files <- length(unique(all_results$file))


# Crear el violin plot para GC_Content
ggplot(all_results, aes(x = file, y = GC_Content)) +
  geom_violin(fill = palmer_colors[2], alpha = 0.7, width = 0.5) +
  geom_boxplot(width = 0.1, fill = "white", alpha = 0.3) +
  geom_jitter(width = 0.1, alpha = 0.1, color = "black") +
  theme_minimal() +
  labs(#title = "Distribución del contenido de GC por archivo",
       x = "Archivo",
       y = "Contenido de GC")


```

### Distribución de la longitud de secuencias de `r key_name`

```{r}
#| label: plotting-length
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: true
#| warning: false
#| layout: [[100]]

# Crear el violin plot para Length
ggplot(all_results, aes(x = file, y = Length)) +
  geom_violin(fill = palmer_colors[1], alpha = 0.7, width = 0.5) +
  geom_boxplot(width = 0.1, fill = "white", alpha = 0.3) +
  geom_jitter(width = 0.1, alpha = 0.1, color = "black") +
  facet_wrap(~file, ncol = num_files, scales = "free") +
  theme_minimal() +
  labs(#title = "Distribución de la longitud de secuencias por archivo",
       x = "Archivo",
       y = "Longitud")

# Combinar todos los gráficos en uno solo usando grid.arrange
# combined_plot <- grid.arrange(seq_length, seq_gc, nrow = 2)


```


-----

## Filtrado de las secuencias de `r key_name` por el largo

Las secuencias de `r key_name` poseen un largo minimo de (debe ser variable) 8000 pb??, siendo el largo minimo de filtrado. Las secuencias menores a este minimo se descartaran dado que no contienen a `r key_name` en su totalidad.

```{r}
#| label: filter-seq
#| echo: true
#| warning: false

length_min <- mean(all_results$Length)

filter_data_higher <- filter(all_results, Length >= length_min) 
filter_data_smaller <- filter(all_results, Length <= length_min)

# filter_seq_higher <- fasta_content[sapply(fasta_content, length) >= length_min]
# filter_seq_smaller <- fasta_content[sapply(fasta_content, length) <= length_min]

```


### Resumen de Información de `r key_name` en cada genoma filtrado por el largo

Se crea una nueva tabla resumen a partir de las `r key_name` `que comprenden el largo minimo` agrupandos por genomas, calculando el `número total` de secuencias, la `longitud` mínima, media y máxima, así como el contenido de `GC` mínimo, medio y máximo.

```{r}
#| label: plotting-function
#| echo: false
#| warning: false

violin_plot <- function(data, file_col, value_col, num_files, n, archivo_label, y_label) {
  ggplot(data, aes_string(x = file_col, y = value_col)) +
    geom_violin(fill = palmer_colors[n], alpha = 0.7, width = 0.5) +
    geom_boxplot(width = 0.1, fill = "white", alpha = 0.3) +
    geom_jitter(width = 0.1, alpha = 0.1, color = "black") +
    facet_wrap(as.formula(paste("~", file_col)), ncol = num_files, scales = "free") +
    theme_minimal() +
    labs(x = archivo_label, y = y_label)
}


```

```{r}
#| label: summary-info_higher
#| echo: false
#| warning: false

# Crear una tabla con el conteo de secuencias por archivo
file_sequence_counts <- filter_data_higher %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(file_sequence_counts, highlight = TRUE)

```

### Distribución del contenido de GC de las secuencias de `r key_name` >= (lago minimo) debe ser variable

```{r}
#| label: plotting-GC-filter
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: false
#| warning: false
#| layout: [[100]]

violin_plot(filter_data_higher, "file", "GC_Content", num_files, 2, "Archivo", "Longitud")

```

### Distribucion de largo de las secuencias de `r key_name` >= (lago minimo) debe ser variable

```{r}
#| label: plotting-length-filter
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: false
#| warning: false
#| layout: [[100]]

violin_plot(filter_data_higher, "file", "Length", num_files, 1, "Archivo", "Longitud")

```

---

## Resumen de Información de secuencias menores al largo minimo establecido

Se crea una nueva tabla resumen a partir de las secuencias que se descartaran por no cumplir con el minimo establecido, se agrupa las secuencias por archivo, calculando el `número total` de secuencias, la `longitud` mínima, media y máxima, así como el contenido de `GC` mínimo, medio y máximo.

```{r}
#| label: summary-info-smaller
#| echo: false
#| warning: false

# Crear una tabla con el conteo de secuencias por archivo
file_sequence_counts <- filter_data_smaller %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(file_sequence_counts, highlight = TRUE)

```
